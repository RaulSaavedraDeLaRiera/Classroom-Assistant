import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { User } from './schemas/user.schema';
import { Course } from '../courses/schemas/course.schema';
import { StudentModule } from '../students/schemas/student-module.schema';
import { CourseEnrollment } from '../courses/schemas/course-enrollment.schema';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    @InjectModel(Course.name) private courseModel: Model<Course>,
    @InjectModel(StudentModule.name) private studentModuleModel: Model<StudentModule>,
    @InjectModel(CourseEnrollment.name) private courseEnrollmentModel: Model<CourseEnrollment>
  ) {}

  // get all users with optional filters
  async getAllUsers(query: any): Promise<User[]> {
    const filter: any = { visible: true };
    
    if (query.role) filter.role = query.role;
    if (query.active !== undefined) filter.active = query.active === 'true';
    
    return this.userModel.find(filter).exec();
  }

  // create new user
  async createUser(createUserDto: any): Promise<User> {
    const newUser = new this.userModel(createUserDto);
    return newUser.save();
  }

  // create new student and associate with teacher
  async createStudentWithTeacher(createStudentDto: any, teacherId: string): Promise<any> {
    const { email, name } = createStudentDto;
    const teacherObjectId = new Types.ObjectId(teacherId);
    
    // Check if student already exists by email
    const existingStudent = await this.userModel.findOne({ email, visible: true }).exec();
    
    if (existingStudent) {
      // Student exists - check if already associated with this teacher
      if (existingStudent.teacherIds && existingStudent.teacherIds.includes(teacherObjectId)) {
        throw new Error('Student is already associated with this teacher');
      }
      
      // Student exists but not associated - add teacher to student's teacherIds
      const updatedStudent = await this.userModel.findByIdAndUpdate(
        existingStudent._id,
        { $addToSet: { teacherIds: teacherObjectId } },
        { new: true, runValidators: true }
      ).exec();
      
      return {
        ...updatedStudent.toObject(),
        action: 'added_existing_student',
        message: 'Existing student added to teacher successfully',
        autoGeneratedPassword: null // No new password for existing student
      };
    } else {
      // Student doesn't exist - create new one
      const autoPassword = this.generatePasswordFromEmail(email);
      
      const studentData = {
        name,
        email,
        role: 'student',
        teacherIds: [teacherObjectId],
        password: autoPassword
      };
      
      const newStudent = new this.userModel(studentData);
      const savedStudent = await newStudent.save();
      
      return {
        ...savedStudent.toObject(),
        action: 'created_new_student',
        message: 'New student created and associated with teacher successfully',
        autoGeneratedPassword: autoPassword
      };
    }
  }

  // Generate password based on email (part before @) + random numbers
  private generatePasswordFromEmail(email: string): string {
    const emailPart = email.split('@')[0];
    return emailPart; // Just the part before @, no random numbers
  }

  // get user by id
  async getUserById(id: string): Promise<User> {
    const user = await this.userModel.findOne({ _id: id, visible: true }).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  // get user by email
  async findByEmail(email: string): Promise<User | null> {
    return this.userModel.findOne({ email, visible: true }).exec();
  }

  // update user completely
  async updateUser(id: string, updateUserDto: any): Promise<User> {
    const updatedUser = await this.userModel.findByIdAndUpdate(
      id,
      updateUserDto,
      { new: true, runValidators: true }
    ).exec();
    
    if (!updatedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return updatedUser;
  }

  // partial update of user
  async partialUpdateUser(id: string, partialUpdateDto: any): Promise<User> {
    const updatedUser = await this.userModel.findByIdAndUpdate(
      id,
      { $set: partialUpdateDto },
      { new: true, runValidators: true }
    ).exec();
    
    if (!updatedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return updatedUser;
  }

  // update only user role
  async updateUserRole(id: string, roleUpdateDto: any): Promise<User> {
    const { role } = roleUpdateDto;
    const updatedUser = await this.userModel.findByIdAndUpdate(
      id,
      { role },
      { new: true, runValidators: true }
    ).exec();
    
    if (!updatedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return updatedUser;
  }

  // delete or deactivate user (soft delete)
  async deleteUser(id: string): Promise<User> {
    const deletedUser = await this.userModel.findByIdAndUpdate(
      id,
      { visible: false },
      { new: true }
    ).exec();
    
    if (!deletedUser) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return deletedUser;
  }

  // get teachers with course and student counts
  async getTeachersStats(): Promise<any[]> {
    const teachers = await this.userModel.find({ 
      role: 'teacher', 
      visible: true, 
      active: true 
    }).exec();

    // Get real stats for each teacher
    const teachersWithStats = await Promise.all(
      teachers.map(async (teacher) => {
        // Count courses for this teacher
        const coursesCount = await this.courseModel.countDocuments({
          teacherId: teacher._id,
          visible: true
        });

        // Count students enrolled in this teacher's courses
        const courseIds = await this.courseModel.find({ teacherId: teacher._id }).distinct('_id');
        const studentsCount = await this.courseEnrollmentModel.countDocuments({
          courseId: { $in: courseIds },
          status: 'active',
          visible: true
        });

        return {
          _id: teacher._id,
          name: teacher.name,
          email: teacher.email,
          active: teacher.active,
          createdAt: teacher.createdAt,
          coursesCount,
          studentsCount,
          lastLoginAt: teacher.lastLoginAt
        };
      })
    );

    return teachersWithStats;
  }

  // get students with teacher and course info
  async getStudentsStats(): Promise<any[]> {
    const students = await this.userModel.find({ 
      role: 'student', 
      visible: true, 
      active: true 
    }).exec();

    // Get real stats for each student
    const studentsWithStats = await Promise.all(
      students.map(async (student) => {
        // Get courses where this student is enrolled from CourseEnrollment
        const enrollments = await this.courseEnrollmentModel.find({
          studentId: student._id,
          status: 'active',
          visible: true
        }).populate('courseId').populate('teacherId').exec();

        const coursesCount = enrollments.length;
        
        // Calculate average progress from enrollments
        const totalProgress = enrollments.reduce((sum, enrollment) => sum + (enrollment.progress || 0), 0);
        const progress = coursesCount > 0 ? Math.round(totalProgress / coursesCount) : 0;

        // Get teacher name from first enrollment
        let teacherName = 'Not Assigned';
        if (coursesCount > 0 && enrollments[0].teacherId) {
          const teacher = enrollments[0].teacherId as any;
          teacherName = teacher ? teacher.name : 'Not Assigned';
        }

        return {
          _id: student._id,
          name: student.name,
          email: student.email,
          active: student.active,
          createdAt: student.createdAt,
          teacherName,
          coursesCount,
          progress,
          lastLoginAt: student.lastLoginAt
        };
      })
    );

    return studentsWithStats;
  }

  // get user details with related data
  async getUserDetails(id: string): Promise<any> {
    const user = await this.userModel.findOne({ 
      _id: id, 
      visible: true 
    }).exec();

    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }

    // Basic user info
    const userDetails = {
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      active: user.active,
      createdAt: user.createdAt,
      lastLoginAt: user.lastLoginAt,
      tags: user.tags,
      profile: user.profile
    };

    // Add role-specific data
    if (user.role === 'teacher') {
      // Get teacher's courses
      const courses = await this.courseModel.find({
        teacherId: user._id,
        visible: true
      }).select('title description status').exec();

      // Get students enrolled in teacher's courses
      const courseIds = courses.map(course => course._id);
      const studentModules = await this.studentModuleModel.find({
        courseId: { $in: courseIds }
      }).populate('studentId').exec();

      const students = studentModules.map(module => {
        const student = module.studentId as any;
        return {
          _id: student._id,
          name: student.name,
          email: student.email
        };
      });

      userDetails['courses'] = courses;
      userDetails['students'] = students;
    } else if (user.role === 'student') {
      // Get student's enrolled courses from CourseEnrollment
      const enrollments = await this.courseEnrollmentModel.find({
        studentId: user._id,
        status: 'active',
        visible: true
      }).populate('courseId').populate('teacherId').exec();

      const courses = enrollments.map(enrollment => {
        const course = enrollment.courseId as any;
        return {
          _id: course._id,
          title: course.title,
          description: course.description,
          progress: enrollment.progress || 0,
          totalExercises: enrollment.totalExercises || 0,
          completedExercises: enrollment.completedExercises || 0,
          totalModules: enrollment.totalModules || 0,
          completedModules: enrollment.completedModules || 0,
          averageScore: enrollment.averageScore || 0,
          totalPoints: enrollment.totalPoints || 0,
          earnedPoints: enrollment.earnedPoints || 0
        };
      });

      // Get assigned teacher from first enrollment
      let teacher = null;
      if (enrollments.length > 0 && enrollments[0].teacherId) {
        const teacherUser = enrollments[0].teacherId as any;
        teacher = {
          _id: teacherUser._id,
          name: teacherUser.name,
          email: teacherUser.email
        };
      }

      // Calculate progress per course
      const progress = {};
      enrollments.forEach(enrollment => {
        const courseId = enrollment.courseId._id.toString();
        progress[courseId] = enrollment.progress || 0;
      });

      userDetails['teacher'] = teacher;
      userDetails['courses'] = courses;
      userDetails['progress'] = progress;
    }

    return userDetails;
  }

  // get students by teacher ID (students where teacherIds array includes the teacher)
  async getStudentsByTeacher(teacherId: string): Promise<User[]> {
    const teacherObjectId = new Types.ObjectId(teacherId);
  
    const students = await this.userModel.find({
      role: 'student',
      visible: true,
      teacherIds: teacherObjectId
    }).select('_id name email active createdAt tags').exec();


    
    return students;
  }

  // get student by ID
  async getStudentById(studentId: string): Promise<User> {
    const student = await this.userModel.findOne({ 
      _id: studentId, 
      role: 'student', 
      visible: true 
    }).select('_id name email active createdAt tags role').exec();

    if (!student) {
      throw new NotFoundException(`Student with ID ${studentId} not found`);
    }

    return student;
  }

  // add teacher to student's teacherIds array
  async addTeacherToStudent(studentId: string, teacherId: string): Promise<User> {
    const updatedStudent = await this.userModel.findByIdAndUpdate(
      studentId,
      { $addToSet: { teacherIds: teacherId } },
      { new: true, runValidators: true }
    ).exec();

    if (!updatedStudent) {
      throw new NotFoundException(`Student with ID ${studentId} not found`);
    }

    return updatedStudent;
  }

  // remove teacher from student's teacherIds array
  async removeTeacherFromStudent(studentId: string, teacherId: string): Promise<User> {
    const updatedStudent = await this.userModel.findByIdAndUpdate(
      studentId,
      { $pull: { teacherIds: teacherId } },
      { new: true, runValidators: true }
    ).exec();

    if (!updatedStudent) {
      throw new NotFoundException(`Student with ID ${studentId} not found`);
    }

    return updatedStudent;
  }

  // intelligently remove student from teacher (smart deletion)
  async removeStudentFromTeacher(studentId: string, teacherId: string): Promise<any> {
    const student = await this.userModel.findById(studentId).exec();
    if (!student) {
      throw new NotFoundException(`Student with ID ${studentId} not found`);
    }

    // Check if student has other teachers
    const hasOtherTeachers = student.teacherIds && student.teacherIds.length > 1;
    
    if (hasOtherTeachers) {
      // Student has other teachers - just remove this teacher
      await this.removeTeacherFromStudent(studentId, teacherId);
      
      // Remove from teacher's courses but keep student record
      // TODO: Implement course enrollment removal
      
      return {
        message: 'Student removed from teacher but kept in system (has other teachers)',
        action: 'removed_from_teacher',
        studentKept: true
      };
    } else {
      // Student only has this teacher - remove from teacher but keep basic record
      await this.removeTeacherFromStudent(studentId, teacherId);
      
      // Mark student as inactive but don't delete
      await this.userModel.findByIdAndUpdate(
        studentId,
        { 
          active: false,
          teacherIds: []
        }
      ).exec();
      
      // TODO: Implement course enrollment removal
      
      return {
        message: 'Student deactivated and removed from teacher (no other teachers)',
        action: 'deactivated_student',
        studentKept: true
      };
    }
  }
}
